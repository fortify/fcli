apply plugin: "java"
apply plugin: "io.freefair.lombok"

// Define Java version
java {
	sourceCompatibility = JavaVersion.toVersion("17")
	targetCompatibility = JavaVersion.toVersion("17")
}

/*
eclipse {
    classpath {
        file.whenMerged { cp ->
            cp.entries.add( new org.gradle.plugins.ide.eclipse.model.SourceFolder('src/main/zipped-resources', null) )
        }
    }
}
*/
sourceSets {
    main {
        resources {
            exclude '**/zip/*'
            exclude '**/zip'
        }
    }
}

dependencies {
	implementation platform(project("${fcliBomRef}"))
	annotationProcessor platform(project("${fcliBomRef}"))
	
	// Picocli dependency & annotation processor
	// TODO Re-enable when removing patched picocli classes from fcli-common
	//implementation("info.picocli:picocli")
	annotationProcessor("info.picocli:picocli-codegen")
	
	// Generate GraalVM reflect-config.json using annotations
	compileOnly('com.formkiq:graalvm-annotations')
	annotationProcessor('com.formkiq:graalvm-annotations-processor')

	// REST client
	implementation('com.konghq:unirest-java') {
		exclude group: 'com.google.code.gson', module: 'gson' // We use Jackson, so no need for Gson
		exclude group: 'commons-logging', module: 'commons-logging' // We use jcl-over-slf4j
	}
	implementation('com.konghq:unirest-objectmapper-jackson')
	
	// Spring expression language (SpEL)
	implementation('org.springframework:spring-expression')
    // Support for JSON/SpEL date/time formatting
    implementation('org.springframework:spring-context')
        
	// Remove annotation processor warning
	compileOnly('com.google.code.findbugs:jsr305')
	
    // Logging dependencies
	implementation('org.slf4j:slf4j-api')
	implementation('org.slf4j:jcl-over-slf4j')
	implementation('ch.qos.logback:logback-classic')

	// Jackson data formats & types
	implementation('com.fasterxml.jackson.dataformat:jackson-dataformat-yaml')
	implementation('com.fasterxml.jackson.dataformat:jackson-dataformat-csv')
	implementation("com.fasterxml.jackson.dataformat:jackson-dataformat-xml")
	implementation("com.fasterxml.jackson.datatype:jackson-datatype-jsr310")
	implementation 'com.fasterxml.jackson.datatype:jackson-datatype-jdk8'
	
	// Output formatting
	implementation('hu.webarticum:tree-printer')
	implementation('com.github.freva:ascii-table')
	
	// Encryption library
	implementation('org.jasypt:jasypt')
	
	// Test dependencies
	testImplementation 'org.junit.jupiter:junit-jupiter-api'
	testImplementation 'org.junit.jupiter:junit-jupiter-params'
	testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine'
    testRuntimeOnly 'org.junit.platform:junit-platform-launcher'

    // Required for unpacking tar.gz (debricked cli)
    implementation('org.apache.commons:commons-compress')
    
    // Used for processing HTML text returned by SSC/FoD endpoints like issue summaries/details/...
    implementation('org.jsoup:jsoup')
}
    
compileJava {
	// Enable verbose logging for picocli annotation processor
	// The reflect-config.json generated by the picocli annotation processor
	// is lacking many entries, hence we disable this functionality here and
	// use a separate generatePicocliReflectConfig task to generate a proper 
	// reflect-config.json file. 
	options.compilerArgs += ["-Averbose=true","-Adisable.reflect.config=true"]
}
    
test {
	useJUnitPlatform()
	// Show test output in Gradle output, sometimes easier than opening the
	// test reports in a browser
	testLogging {
		showStandardStreams = true
	}
}

ext.generatedZipResourcesDir = "${buildDir}/generated-zip-resources"
/* For some reason the below doesn't work, probably related to https://github.com/gradle/gradle/issues/24368
 * For now, we just have dedicated zip tasks in SSC/FoD build.gradle files
fileTree(dir: 'src/main/zipped-resources')
    .visit { e -> if ( e.isDirectory() && e.name=='zip' ) {
        def zipTaskName = "zipResources_${e.path.replaceAll('/', '_')}" 
        def destDir = "$generatedZipResourcesDir/${e.relativePath}"
        def zipName = "${e.relativePath.parent.lastName}.zip"
        def from    = "${e.file.absolutePath}"
        println "zipTaskName: $zipTaskName"
        println "destDir:     $destDir"
        println "zipName:     $zipName"
        println "from:        $from"
        tasks.create(name: "$zipTaskName", type: Zip) {
            destinationDirectory = file("$destDir")
            archiveFileName = "$zipName"
            from = file("$from")
        }
    }}
*/
task generateZipResources(dependsOn: tasks.matching { Task task -> task.name.startsWith("zipResources_")})
sourceSets.main.output.dir generatedZipResourcesDir, builtBy: generateZipResources
    
// Generate resource-config.json
ext.generatedResourceConfigDir = "${buildDir}/generated-resource-config"
tasks.register('generateResourceConfig') {
    dependsOn = [generateZipResources]
	doLast {
		def outputDir = "${generatedResourceConfigDir}/META-INF/native-image/fcli-generated/${project.name}";
		mkdir "${outputDir}"
		def entries = [];
		fileTree(dir: 'src/main/resources', excludes: ['**/i18n/**', 'META-INF/**', '**/zip/**'])
			.visit {e -> if ( !e.isDirectory() ) {entries << '\n  {"pattern":"'+e.relativePath+'"}'}};
        fileTree(dir: generatedZipResourcesDir)
            .visit {e -> if ( !e.isDirectory() ) {entries << '\n  {"pattern":"'+e.relativePath+'"}'}};
		if ( entries.size>0 ) {
			def contents = '{"resources":[' + entries.join(",") + '\n]}';
			file("${outputDir}/resource-config.json").text = contents;
			println contents
		}
	}
}
sourceSets.main.output.dir generatedResourceConfigDir, builtBy: generateResourceConfig